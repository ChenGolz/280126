/* Vegan in Israel page logic (page-only) */
(() => {
  const $ = (sel, root = document) => root.querySelector(sel);
  const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));

  const DATA_URL = 'data/vegan-in-israel.json?v=2026-01-30-v6';
  const STATE = {
    places: [],
    filter: {
      q: '',
      region: 'all',
      type: 'all' // restaurant | shop | all
    },
    map: null,
    markers: []
  };

  function normalize(str) {
    return (str || '')
      .toString()
      .toLowerCase()
      .trim();
  }


  // Client-side geocoding for places missing coordinates (cached in localStorage)
  // This lets you add new places by address only, and the map will pin them automatically.
  const GEO_CACHE_KEY = 'vii_geocode_cache_v1';
  const GEO = {
    cache: loadGeoCache(),
    pending: new Set(),
    running: false
  };

  function loadGeoCache() {
    try {
      const raw = localStorage.getItem(GEO_CACHE_KEY);
      const parsed = raw ? JSON.parse(raw) : {};
      return (parsed && typeof parsed === 'object') ? parsed : {};
    } catch {
      return {};
    }
  }

  function saveGeoCache() {
    try {
      localStorage.setItem(GEO_CACHE_KEY, JSON.stringify(GEO.cache || {}));
    } catch {
      // ignore (private mode / storage disabled)
    }
  }

  function sleep(ms) {
    return new Promise(r => setTimeout(r, ms));
  }

  function hasCoords(p) {
    return Number.isFinite(p.lat) && Number.isFinite(p.lng);
  }

  function applyCachedCoords(p) {
    if (hasCoords(p)) return;
    const cached = GEO.cache?.[p.id];
    if (cached && Number.isFinite(cached.lat) && Number.isFinite(cached.lng)) {
      p.lat = Number(cached.lat);
      p.lng = Number(cached.lng);
    }
  }

  function buildGeocodeQuery(p) {
    const addr = (p.address_he || p.address || '').trim();
    const city = (p.city_he || p.city || '').trim();
    // Keep it simple and robust for Hebrew/English inputs
    return [addr, city, 'ישראל'].filter(Boolean).join(', ');
  }

  async function geocodePlace(p) {
    if (!p || hasCoords(p)) return;
    if (GEO.pending.has(p.id)) return;
    GEO.pending.add(p.id);

    const q = buildGeocodeQuery(p);
    const url = `https://nominatim.openstreetmap.org/search?format=json&limit=1&countrycodes=il&accept-language=he&q=${encodeURIComponent(q)}`;

    try {
      const res = await fetch(url, {
        headers: { 'Accept': 'application/json' }
      });
      if (!res.ok) throw new Error('Geocode failed');
      const data = await res.json();
      const hit = Array.isArray(data) ? data[0] : null;
      const lat = hit ? Number(hit.lat) : NaN;
      const lng = hit ? Number(hit.lon) : NaN;

      if (Number.isFinite(lat) && Number.isFinite(lng)) {
        p.lat = lat;
        p.lng = lng;
        GEO.cache[p.id] = { lat, lng, ts: Date.now() };
        saveGeoCache();
      }
    } catch (e) {
      // silent fail — the list still works even without a pin
      console.warn('Geocode failed for', p?.id, q);
    } finally {
      GEO.pending.delete(p.id);
    }
  }

  async function geocodeMissing() {
    if (GEO.running) return;
    GEO.running = true;

    // First, apply cache to everything
    STATE.places.forEach(applyCachedCoords);

    // Then, geocode missing items slowly (polite to the free service)
    const missing = STATE.places.filter(p => !hasCoords(p));
    for (const p of missing) {
      await geocodePlace(p);
      // Re-render progressively so pins appear quickly
      renderMap({ fit: false });
      renderList();
      await sleep(350);
    }

    GEO.running = false;
  }

  function formatAddress(p) {
    return (document.documentElement.lang === 'he' || document.documentElement.dir === 'rtl')
      ? (p.address_he || p.address || '')
      : (p.address || p.address_he || '');
  }

  function formatName(p) {
    return (document.documentElement.lang === 'he' || document.documentElement.dir === 'rtl')
      ? (p.name_he || p.name || '')
      : (p.name || p.name_he || '');
  }

  function formatNotes(p) {
    return (document.documentElement.lang === 'he' || document.documentElement.dir === 'rtl')
      ? (p.notes_he || '')
      : (p.notes_en || p.notes_he || '');
  }

  function mapQueryLink(p) {
    const addr = encodeURIComponent(p.address || p.address_he || p.name || '');
    return `https://www.google.com/maps/search/?api=1&query=${addr}`;
  }

  function passesFilter(p) {
    const q = normalize(STATE.filter.q);
    const regionOk = (STATE.filter.region === 'all') || (normalize(p.region) === STATE.filter.region);
    const typeOk = (STATE.filter.type === 'all') || (p.type === STATE.filter.type);

    if (!regionOk || !typeOk) return false;
    if (!q) return true;

    const hay = [
      p.name, p.name_he, p.city, p.city_he, p.address, p.address_he,
      p.region, p.region_he, p.typeLabel_he, p.notes_he, p.notes_en
    ].filter(Boolean).map(normalize).join(' ');
    return hay.includes(q);
  }

  function pill(label) {
    return `<span class="pill">${label}</span>`;
  }

  function typeLabel(p) {
    if (document.documentElement.lang === 'he' || document.documentElement.dir === 'rtl') {
      return p.typeLabel_he || (p.type === 'shop' ? 'חנות' : 'מסעדה');
    }
    return p.type === 'shop' ? 'Shop' : 'Restaurant';
  }

  function renderList() {
    const grid = $('#placesGrid');
    const items = STATE.places.filter(passesFilter);

    if (!items.length) {
      grid.innerHTML = `
        <div class="contentCard" style="grid-column:1/-1;">
          <h3 style="margin:0 0 .25rem;">לא מצאנו התאמה</h3>
          <p style="margin:0;">נסו לשנות חיפוש/אזור או להסיר פילטרים.</p>
        </div>`;
      return;
    }

    grid.innerHTML = items.map(p => {
      const name = formatName(p);
      const addr = formatAddress(p);
      const notes = formatNotes(p);
      const city = (document.documentElement.lang === 'he' || document.documentElement.dir === 'rtl') ? (p.city_he || p.city) : (p.city || p.city_he);
      const region = (document.documentElement.lang === 'he' || document.documentElement.dir === 'rtl') ? (p.region_he || p.region) : (p.region || p.region_he);

      const pills = [
        pill(typeLabel(p)),
        city ? pill(city) : '',
        region ? pill(region) : '',
      ].join('');

      const siteLink = p.website ? `<a class="btnSmall" href="${p.website}" target="_blank" rel="noopener">אתר</a>` : '';
      const igLink = p.instagram ? `<a class="btnSmall" href="${p.instagram}" target="_blank" rel="noopener">אינסטגרם</a>` : '';
      const mapsLink = `<a class="btnSmall" href="${mapQueryLink(p)}" target="_blank" rel="noopener">מפות</a>`;

      return `
        <article class="placeCard contentCard">
          <div class="placeCardTop">
            <h3 class="placeTitle">${escapeHtml(name)}</h3>
            <div class="pillRow">${pills}</div>
          </div>

          <p class="placeAddr">${escapeHtml(addr)}</p>
          ${notes ? `<p class="placeNotes">${escapeHtml(notes)}</p>` : ''}

          <div class="placeActions">
            ${mapsLink}
            ${siteLink}
            ${igLink}
            <button class="btnSmall btnGhost" data-focus="${p.id}">הצג במפה</button>
          </div>
        </article>`;
    }).join('');

    // attach handlers
    $$('#placesGrid [data-focus]').forEach(btn => {
      btn.addEventListener('click', () => {
        const id = btn.getAttribute('data-focus');
        focusOn(id);
      });
    });
  }

  function clearMarkers() {
    STATE.markers.forEach(m => m.remove());
    STATE.markers = [];
  }

  function renderMap(opts = {}) {
    const mapEl = $('#veganMap');
    if (!mapEl) return;

    if (!STATE.map) {
      // Leaflet must exist
      if (!window.L) {
        mapEl.innerHTML = '<p style="margin:0;">המפה לא נטענה (Leaflet לא זמין).</p>';
        return;
      }
      STATE.map = L.map('veganMap', { scrollWheelZoom: false }).setView([31.7, 34.8], 7);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '&copy; OpenStreetMap'
      }).addTo(STATE.map);
    }

    clearMarkers();

    const items = STATE.places.filter(passesFilter).filter(p => Number.isFinite(p.lat) && Number.isFinite(p.lng));
    items.forEach(p => {
      const marker = L.marker([p.lat, p.lng]).addTo(STATE.map);
      marker.bindPopup(`
        <div style="min-width:180px;">
          <strong>${escapeHtml(formatName(p))}</strong><br/>
          <small>${escapeHtml(formatAddress(p))}</small><br/>
          <a href="${mapQueryLink(p)}" target="_blank" rel="noopener">פתח במפות</a>
        </div>
      `);
      marker.__placeId = p.id;
      STATE.markers.push(marker);
    });

    // Fit bounds only when filters change (or first render). Avoid overriding a focused view.
    const key = JSON.stringify([STATE.filter.q, STATE.filter.region, STATE.filter.type, items.length]);
    const wantFit = (opts.fit === true) || (opts.fit !== false && key !== STATE.fitKey);

    if (STATE.markers.length) {
      if (wantFit) {
        const group = new L.featureGroup(STATE.markers);
        STATE.map.fitBounds(group.getBounds().pad(0.2));
        STATE.fitKey = key;
      }
    } else {
      if (wantFit) {
        STATE.map.setView([31.7, 34.8], 7);
        STATE.fitKey = key;
      }
    }
  }

  async function focusOn(placeId) {
    const pid = String(placeId);
    const p = STATE.places.find(x => String(x.id) === pid);
    if (!p) return;
    if (!STATE.map) { renderMap({ fit: true }); }
    if (!STATE.map) return;
    if (!Number.isFinite(p.lat) || !Number.isFinite(p.lng)) {
      // Try to geocode on-demand if coordinates are missing
      await geocodePlace(p);
      renderMap({ fit: false });
    }
    if (!p || !STATE.map || !Number.isFinite(p.lat) || !Number.isFinite(p.lng)) return;
    STATE.map.setView([p.lat, p.lng], 15, { animate: true });
    const m = STATE.markers.find(mm => String(mm.__placeId) === pid);
    if (m) m.openPopup();
    // scroll to map on mobile
    $('#mapSection')?.scrollIntoView({ behavior: 'smooth', block: 'start' });
  }

  function wireFilters() {
    const q = $('#searchInput');
    const region = $('#regionSelect');
    const type = $('#typeSelect');
    const reset = $('#resetFilters');
    const loadCoords = $('#btnLoadCoords');

    if (q) q.addEventListener('input', () => {
      STATE.filter.q = q.value || '';
      renderMap(); // auto-fit when filter changes
      renderList();
    });

    if (region) region.addEventListener('change', () => {
      STATE.filter.region = region.value;
      renderMap();
      renderList();
    });

    if (type) type.addEventListener('change', () => {
      STATE.filter.type = type.value;
      renderMap();
      renderList();
    });

    if (reset) reset.addEventListener('click', () => {
      STATE.filter = { q: '', region: 'all', type: 'all' };
      if (q) q.value = '';
      if (region) region.value = 'all';
      if (type) type.value = 'all';
      renderMap({ fit: true });
      renderList();
    });

    if (loadCoords) {
      loadCoords.addEventListener('click', async () => {
        if (GEO.running) return;
        const prev = loadCoords.textContent;
        loadCoords.disabled = true;
        loadCoords.textContent = 'טוען…';
        try {
          await geocodeMissing(); // progressive render inside
        } finally {
          loadCoords.textContent = prev;
          loadCoords.disabled = false;
        }
      });
    }
  }

  async function load() {
    try {
      const res = await fetch(DATA_URL, { cache: 'force-cache' });
      if (!res.ok) throw new Error('Bad response');
      const json = await res.json();
      STATE.places = (json.places || []).map(p => ({
        ...p,
        lat: (p.lat === null || p.lat === undefined) ? null : Number(p.lat),
        lng: (p.lng === null || p.lng === undefined) ? null : Number(p.lng),
      }));
      // Apply cached coordinates (if any)
      STATE.places.forEach(applyCachedCoords);
      const stamp = $('#dataStamp');
      if (stamp && json.updatedAt) stamp.textContent = json.updatedAt;
    } catch (e) {
      console.warn('Vegan in Israel: failed to load data/vegan-in-israel.json', e);
      STATE.places = [];
    }

    // Regions dropdown options based on data
    const region = $('#regionSelect');
    const regions = Array.from(new Set(STATE.places.map(p => normalize(p.region)).filter(Boolean)))
      .sort((a, b) => a.localeCompare(b));
    region.innerHTML = [
      `<option value="all">כל הארץ</option>`,
      ...regions.map(r => `<option value="${r}">${escapeHtml(r === 'jerusalem' ? 'ירושלים' : (r === 'center' ? 'מרכז' : (r === 'north' ? 'צפון' : (r === 'online' ? 'אונליין' : r))))}</option>`)
    ].join('');

    renderMap();
    renderList();
    wireFilters();
  }

  function escapeHtml(str) {
    return String(str ?? '')
      .replaceAll('&', '&amp;')
      .replaceAll('<', '&lt;')
      .replaceAll('>', '&gt;')
      .replaceAll('"', '&quot;')
      .replaceAll("'", '&#039;');
  }

  document.addEventListener('DOMContentLoaded', load);
})();
